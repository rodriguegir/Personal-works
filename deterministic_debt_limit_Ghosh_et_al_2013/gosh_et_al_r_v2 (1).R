# -*- coding: utf-8 -*-
"""gosh_et_al_R_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LAe_MhzK8nQvF62PY04kTF2uE01dWf5R
"""

install.packages(c("readxl", "dplyr", "tidyr", "writexl", "mFilter", "plm"))

library(readxl)
library(dplyr)
library(tidyr)
library(writexl)
library(httr)
library(jsonlite)
library(plm)
library(lmtest)
library(sandwich)
library(mFilter)

# parse IMF API response into dataframe
parse_imf_data <- function(imf_response, indicator_name) {

  indicator_code <- names(imf_response$values)[1]
  countries_data <- imf_response$values[[indicator_code]]

  df_list <- lapply(names(countries_data), function(country) {
    years_values <- countries_data[[country]]

    data.frame(
      country = country,
      year = as.integer(names(years_values)),
      value = as.numeric(unlist(years_values)),
      stringsAsFactors = FALSE
    )
  })

  df <- do.call(rbind, df_list)
  colnames(df)[3] <- indicator_name

  return(df)
}

# download data from IMF API
get_imf_data <- function(indicator_id, country_codes, start_year = 1980, end_year = 2022) {

  base_url <- "https://www.imf.org/external/datamapper/api/v1"
  countries <- paste(country_codes, collapse = "/")
  years <- paste(start_year:end_year, collapse = ",")

  url <- paste0(base_url, "/", indicator_id, "/", countries, "?periods=", years)

  cat("downloading:", indicator_id, "\n")

  response <- GET(url)

  if (status_code(response) != 200) {
    cat("error:", status_code(response), "\n")
    return(NULL)
  }

  data <- content(response, "text", encoding = "UTF-8")
  result <- fromJSON(data, flatten = TRUE)

  return(result)
}

# download data
countries <- c("AUS", "AUT", "BEL", "CAN", "DNK", "FIN", "FRA", "DEU",
             "GRC", "ISL", "IRL", "ISR", "ITA", "JPN", "KOR", "NLD",
             "NZL", "NOR", "PRT", "ESP", "SWE", "GBR", "USA")

#

start_year<-1980
end_year <- 2024

# download data
debt_df <- parse_imf_data(get_imf_data("GGXWDG_NGDP", countries, start_year, end_year), "debt_to_gdp")
pb_df <- parse_imf_data(get_imf_data("pb", countries, start_year, end_year), "primary_balance")
interest_df <- parse_imf_data(get_imf_data("ie", countries, start_year, end_year), "interest_pct_gdp")
real_growth_df <- parse_imf_data(get_imf_data("rgc", countries, start_year, end_year), "r_gdp_growth")
inflation_df <- parse_imf_data(get_imf_data("PCPIPCH", countries, start_year, end_year), "inflation")
exp_df <- parse_imf_data(get_imf_data("prim_exp", countries, start_year, end_year), "govt_expenditure")

# calculate nominal interest rate (r) from interest payments
# assumption: r ≈ (interest / lagged_debt) × 100
# note: simplified version ignoring nominal gdp growth adjustment
calculate_r_nominal <- function(interest_pct_gdp, lagged_debt) {
  r_nominal <- (interest_pct_gdp / lagged_debt) * 100
  return(r_nominal)
}

# calculate nominal gdp growth (g) from real growth and inflation
# fisher equation approximation: n_gdp_growth ≈ r_gdp_growth + inflation
calculate_n_gdp_growth <- function(r_gdp_growth, inflation) {
  n_gdp_growth <- r_gdp_growth + inflation
  return(n_gdp_growth)
}

# merge and create variables
fiscal_data <- debt_df %>%
  left_join(pb_df, by = c("country", "year")) %>%
  left_join(interest_df, by = c("country", "year")) %>%
  left_join(real_growth_df, by = c("country", "year")) %>%
  left_join(inflation_df, by = c("country", "year")) %>%
  left_join(exp_df, by = c("country", "year")) %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(
    lagged_debt = dplyr::lag(debt_to_gdp, n = 1),
    lagged_debt_sq = lagged_debt^2,
    lagged_debt_cubic = lagged_debt^3,

    # calculate r and nominal gdp growth
    r_nominal = calculate_r_nominal(interest_pct_gdp, lagged_debt),
    n_gdp_growth = calculate_n_gdp_growth(r_gdp_growth, inflation),

    # HP filter pour govt_expenditure trend
    govt_exp_trend = if(sum(!is.na(govt_expenditure)) >= 10) {
      hp_result <- hpfilter(govt_expenditure[!is.na(govt_expenditure)], freq = 100)
      hp_trend <- rep(NA, length(govt_expenditure))
      hp_trend[!is.na(govt_expenditure)] <- hp_result$trend
      hp_trend
    } else {
      NA_real_
    },
    govt_exp_gap = govt_expenditure - govt_exp_trend,

    # HP filter pour r_gdp_growth (output gap)
    gdp_trend = if(sum(!is.na(r_gdp_growth)) >= 10) {
      hp_result <- hpfilter(r_gdp_growth[!is.na(r_gdp_growth)], freq = 100)
      hp_trend <- rep(NA, length(r_gdp_growth))
      hp_trend[!is.na(r_gdp_growth)] <- hp_result$trend
      hp_trend
    } else {
      NA_real_
    },
    output_gap = r_gdp_growth - gdp_trend
  ) %>%
  ungroup()

fiscal_data <- fiscal_data %>%
  filter(
    !is.na(debt_to_gdp) &
    !is.na(primary_balance) &
    !is.na(r_gdp_growth) &
    !is.na(govt_expenditure) &
    !is.na(lagged_debt) &
    !is.na(output_gap) &
    !is.na(govt_exp_gap) &
    !is.na(r_nominal) &
    !is.na(n_gdp_growth)
  )

fiscal_data

# POOLED regression with country fixed effects (Ghosh approach)
model1 <- plm(primary_balance ~ lagged_debt + lagged_debt_sq + lagged_debt_cubic + output_gap +govt_exp_gap,
              data = fiscal_data,
              index = c("country", "year"),
              model = "within",
              effect = "individual")

summary(model1)


# extract fixed effects (μ - different per country)
fixed_fx <- fixef(model1)
print("\nCountry-specific intercepts (μ):")
print(fixed_fx)


##with predicted AR(1) error
model_ar1<- pggls(primary_balance ~ lagged_debt + lagged_debt_sq + lagged_debt_cubic + output_gap + govt_exp_gap,
              data = fiscal_data,
              index = c("country", "year"),
              model = "within",
              effect = "individual")

summary(model_ar1)

# POOLED regression with country fixed effects (Ghosh approach without gvt exp gap)
model2 <- plm(primary_balance ~ lagged_debt + lagged_debt_sq + lagged_debt_cubic + output_gap ,
              data = fiscal_data,
              index = c("country", "year"),
              model = "within",
              effect = "individual")

summary(model2)


# extract fixed effects (μ - different per country)
fixed_fx <- fixef(model2)
print("\nCountry-specific intercepts (μ):")
print(fixed_fx)


# Durbin-Watson test for AR(1)
dw_test <- pdwtest(model2)
cat("\nDurbin-Watson Test for Autocorrelation:\n")
print(dw_test)
cat("DW statistic close to 2 = no autocorrelation\n")
cat("p-value < 0.05 = significant autocorrelation detected\n\n")

##with predicted AR(1) error
model_ar2<- pggls(primary_balance ~ lagged_debt + lagged_debt_sq + lagged_debt_cubic + output_gap ,
              data = fiscal_data,
              index = c("country", "year"),
              model = "within",
              effect = "individual")

summary(model_ar2)





# with more AR structure (and remove square term because non significative)
model_ar2_lag2 <- pggls(primary_balance ~ lagged_debt + lagged_debt_cubic + output_gap + lag(primary_balance, 1),
                        data = fiscal_data,
                        index = c("country", "year"),
                        model = "within")

summary(model_ar2_lag2)

### autocorrelation tests

residuals2 <- residuals(model2)
box_test <- Box.test(residuals2, lag = 1, type = "Ljung-Box")
print(box_test)

residuals_ar2 <- residuals(model_ar2)
box_test <- Box.test(residuals_ar2, lag = 1, type = "Ljung-Box")
print(box_test)

residuals_ar2_lag2 <- residuals(model_ar2_lag2)
box_test <- Box.test(residuals_ar2_lag2, lag = 1, type = "Ljung-Box")
print(box_test)

#"We use the pggls AR(1) (or named model_ar2 here) specification without lagged dependent variable to maintain consistency with Ghosh et al.
#While this specification exhibits residual autocorrelation and the coefficients lose significance under robust standard errors,
#our primary objective is to replicate their fiscal reaction function framework rather than achieve optimal econometric properties.
#The debt limit calculations (d̄) therefore follow their original approach, acknowledging this  choice prioritizes replication over statistical refinement.

###with model AR(1)
#graphic visualization of fiscal reaction function
# get coefficients
b1 <- coef(model_ar2)["lagged_debt"]
b2 <- coef(model_ar2)["lagged_debt_sq"]
b3 <- coef(model_ar2)["lagged_debt_cubic"]

# get mean of fixed effects
mean_fx <- mean(fixef(model_ar1))

# predict with fixed effects added
debt_range <- seq(0, 200, by = 5)
predicted_pb <- mean_fx + b1 * debt_range + b2 * debt_range^2 + b3 * debt_range^3

# plot
plot(debt_range, predicted_pb,
     type = "l",
     lwd = 2,
     xlab = "Lagged debt to GDP (%)",
     ylab = "Primary balance (% GDP)",
     main = "Fiscal Reaction Function\nSelected OECD countries, 1980-2022",
     ylim = c(min(predicted_pb)-1, max(predicted_pb)+1))

abline(h = 0, lty = 2, col = "gray")

# add actual data
points(fiscal_data$lagged_debt,
       fiscal_data$primary_balance,
       pch = 16, col = rgb(0, 0, 0, 0.2), cex = 0.6)

# calculate r-g differential with 10-year rolling average (Ghosh et al. 2013 methodology)
# uses historical 10-year average of r and g, ending at specified year
# you can adjust a x-year avg by changing the window = x
calculate_rg_differential <- function(fiscal_data, end_year, window = 10) {

  rg_data <- fiscal_data %>%
    group_by(country) %>%
    arrange(year) %>%
    mutate(
      # 10-year rolling average of r (right-aligned: uses past 10 years)
      r_10y = rollapply(r_nominal, width = window, FUN = mean,
                        align = "right", fill = NA, na.rm = TRUE),

      # 10-year rolling average of g
      g_10y = rollapply(n_gdp_growth, width = window, FUN = mean,
                        align = "right", fill = NA, na.rm = TRUE),

      # r-g differential
      rg_diff_10y = r_10y - g_10y
    ) %>%
    ungroup() %>%
    filter(year <= end_year)

  return(rg_data)
}

# compute r-g differential
rg_data <- calculate_rg_differential(fiscal_data, end_year = end_year, window = 10)

# summary by country (using most recent 10y average for each country)
rg_summary <- rg_data %>%
  filter(!is.na(rg_diff_10y)) %>%
  group_by(country) %>%
  filter(year == max(year)) %>%
  select(country, year, r_10y, g_10y, rg_diff_10y) %>%
  arrange(rg_diff_10y)

rg_summary

# find crossings
find_crossings_simple <- function(country_code, model, fixed_effects, rg_diff, max_debt = 500) {

  # coefficients
  b1 <- coef(model)["lagged_debt"]
  b2 <- coef(model)["lagged_debt_sq"]
  b3 <- coef(model)["lagged_debt_cubic"]
  mu <- fixed_effects[country_code]

  # r-g en decimal
  rg_decimal <- rg_diff / 100

  # debt range
  debt <- seq(0, max_debt, by = 0.25)

  # deux lignes
  reaction <- mu + b1*debt + b2*debt^2 + b3*debt^3
  interest <- rg_decimal * debt

  # difference
  diff <- reaction - interest

  # detect sign changes by multiplying consecutive elements (negative product = crossing)
  sign_change <- which(diff[-1] * diff[-length(diff)] < 0)

  crossings <- debt[sign_change]


  return(crossings)
}

## these plots combined to the crossings allow us to check graphically what deterministic debt limit each country has (or not) and what d* eahc country has
# simple plot: reaction function vs (r*-g)*d line
plot_simple_reaction <- function(country_code, model, fixed_effects, rg_diff, fiscal_data, debt_to_gdp_range=250) {

  # get coefficients
  b1 <- coef(model)["lagged_debt"]
  b2 <- coef(model)["lagged_debt_sq"]
  b3 <- coef(model)["lagged_debt_cubic"]

  # get country fixed effect
  mu <- fixed_effects[country_code]

  # convert r-g to decimal
  rg_decimal <- rg_diff / 100

  # create debt range
  debt_range <- seq(0, debt_to_gdp_range, by = 1)

  # calculate reaction function
  pb_reaction <- mu + b1*debt_range + b2*debt_range^2 + b3*debt_range^3

  # calculate interest line
  interest_line <- rg_decimal * debt_range

  #plot
  plot(debt_range, pb_reaction,
       type = "l", lwd = 2, col = "blue",
       xlab = "Debt/GDP (%)",
       ylab = "Primary Balance (% GDP)",
       main = paste0(country_code, " - r*-g = ", round(rg_diff, 2), "%"),
       ylim = c(min(c(pb_reaction, interest_line)) - 1,
                max(c(pb_reaction, interest_line)) + 1))

  # add interest line
  lines(debt_range, interest_line, lwd = 1, col = "red", lty = 2)

  # add zero line
  abline(h = 0, lty = 2, col = "gray")

  # legend
  legend("bottomleft",
         legend = c("Reaction function", "(r*-g)*d"),
         col = c("blue", "red"),
         lty = c(1, 2),
         lwd = c(2, 2))
}

# plot all countries
par(mfrow = c(1, 1))

for(i in 1:nrow(rg_summary)) {
  country_code <- rg_summary$country[i]
  rg_diff <- rg_summary$rg_diff_10y[i]
  crossings<- find_crossings_simple(country_code, model_ar2, fixed_fx, rg_diff)
  debt_range_max <- max(max(crossings)+20, 160)
  plot_simple_reaction(country_code, model_ar2, fixed_fx, rg_diff, fiscal_data, debt_range_max)
  cat(country_code, ", max crossing and potential deterministic debt limit d_bar:", max(crossings))

}

###model with lag

# find d_bar with model with lag (dynamic)
find_debt_limit_dynamic <- function(country_code, model, fixed_effects, rg_diff, max_debt = 500) {

  # coefficients
  b1 <- coef(model)["lagged_debt"]
  b3 <- coef(model)["lagged_debt_cubic"]
  b5 <- coef(model)["lag(primary_balance, 1)"]  # persistence coef
  mu <- fixed_effects[country_code]

  # r-g en decimal
  rg_decimal <- rg_diff / 100

  # debt range
  debt <- seq(0, max_debt, by = 0.5)

  # steady-state reaction function: pb* = f(d) / (1 - b5)
  # assume output_gap = 0 in long run
  pb_steady <- (mu + b1*debt + b3*debt^3) / (1 - b5)

  # interest line
  interest <- rg_decimal * debt

  # difference
  diff <- pb_steady - interest

  # detect sign changes by multiplying consecutive elements (negative product = crossing)
  sign_change <- which(diff[-1] * diff[-length(diff)] < 0)

  crossings <- debt[sign_change]

  return(crossings)
}



# with models with lag
plot_w_lag <- function(country_code, model, fixed_effects, rg_diff, max_debt = 450) {

  # coefficients
  b1 <- coef(model)["lagged_debt"]
  b3 <- coef(model)["lagged_debt_cubic"]
  b5 <- coef(model)["lag(primary_balance, 1)"]
  mu <- fixed_effects[country_code]

  # r-g en decimal
  rg_decimal <- rg_diff / 100

  # debt range
  debt <- seq(0, max_debt, by = 1)

  # steady-state reaction
  reaction <- (mu + b1*debt  + b3*debt^3) / (1 - b5)

  # interest line
  interest <- rg_decimal * debt

  # plot
  plot(debt, reaction,
       type = "l", lwd = 2, col = "blue",
       xlab = "Debt/GDP (%)",
       ylab = "Primary Balance (% GDP)",
       main = paste0(country_code, " - r*-g = ", round(rg_diff, 2), "%"))

  lines(debt, interest, lwd = 2, col = "red", lty = 2)
  abline(h = 0, lty = 2, col = "gray")

  legend("topleft", legend = c("Reaction", "(r*-g)*d"),
         col = c("blue", "red"), lty = c(1, 2), lwd = 2)
}


fixed_fx_lag2 <- fixef(model_ar2_lag2)

# plot all
par(mfrow = c(1, 1))

for(i in 1:nrow(rg_summary)) {

  crossings <- find_debt_limit_dynamic(rg_summary$country[i], model_ar2_lag2, fixed_fx_lag2,
                    rg_summary$rg_diff_10y[i])
  debt_max = debt_range_max <- max(max(crossings)+20, 160)
  cat
  plot_w_lag(rg_summary$country[i], model_ar2_lag2, fixed_fx_lag2,
                    rg_summary$rg_diff_10y[i],debt_max)
}